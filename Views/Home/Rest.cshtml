@{
	ViewData["Title"] = "REST";
}

<div class="text-center">
	<h1 class="display-4">REST</h1>
</div>

<br />

<h2>Означення</h2>

<p>
	<b>REST (Representational State Transfer)</b> - архітектурний стиль для розробки веб-додатків. Він використовується для створення <b>API (Application Programming Interface)</b> для взаємодії між клієнтами та серверами.
</p>

<br/>

<h2>MVC vs API</h2>

<b>MVC контролери</b>

<ul>
	<li>
		Працюють з різними адресами, наприклад зараз HomeController обслуговує:
		<ol>
			<li>/Home/Index</li>
			<li>/Home/Introduction</li>
			<li>/Home/IoC</li>
			<li>/Home/Razor</li>
			<li>/Home/Rest</li>
		</ol>
	</li>
	<li>Використовується зазвичай лише з методом HTTP-запиту - GET</li>
	<li>В результаті роботи повертає ViewResult або IActionResult</li>
</ul>

<b>API контролери</b>

<ul>
	<li>
		Працюють з однією адресою, наприклад [api/category]
	</li>
	<li>Метод для роботи визначається за допомогою отримуваного методу HTTP-запиту: GET, POST, PUT, DELETE, PATCH та допоміжних параметрів запиту</li>
	<li>В результаті роботи повертає JsonResult або ObjectResult</li>
</ul>

<h2>Обмеження REST</h2>

<p>REST зобов'язує дотримуватися деяких обмежень. Діючи в межах цих обмежень, система набуває таких бажаних властивостей, як продуктивність, масштабованість, простота, здатність до змін, переносимість, відстежуваність і надійність.</p>

<ol>
	<li>
		<h4>Клієнт-серверна архітектура</h4>
		<p>Відокремлення потреби інтерфейсу клієнта від потреб сервера, що зберігає дані, підвищує переносимість коду клієнтського інтерфейсу на інші платформи, а спрощення серверної частини покращує масштабованість.</p>
	</li>
	<li>
		<h4>Відсутність стану</h4>
		<p>Кожен запит від клієнта до сервера повинен містити всю необхідну інформацію для виконання запиту. Стан сервера не зберігається на клієнті, але може зберігатися на сервері.</p>
	</li>
	<li>
		<h4>Кешування</h4>
		<p>Дані відповіді на запити повинні бути позначені як кешовані або некешовані. Це дозволяє клієнтам кешувати відповіді, щоб уникнути повторних запитів до сервера.</p>
	</li>
	<li>
		<h4>Уніфікований інтерфейс</h4>
		<p>Уніфікований інтерфейс спрощує архітектуру системи, робить її більш зрозумілою і дозволяє розробникам працювати над окремими частинами системи незалежно один від одного.</p>
		<p>Уніфікований інтерфейс включає:</p>
		<ul>
			<li>
				<h5>Ідентифікація ресурсів</h5>
				<p>Кожен ресурс повинен бути ідентифікований унікальним URI.</p>
			</li>
			<li>
				<h5>Маніпуляція ресурсами через представлення</h5>
				<p>Клієнт може маніпулювати ресурсами, використовуючи представлення ресурсів, наприклад XML або JSON.</p>
			</li>
			<li>
				<h5>Самоописуюче повідомлення</h5>
				<p>Кожне повідомлення містить достатньо інформації для розуміння, як обробити це повідомлення.</p>
			</li>
			<li>
				<h5>Гіпермедіа</h5>
				<p>Клієнт може отримати всю необхідну інформацію для взаємодії з додатком, використовуючи гіпермедіа, які він отримує від сервера.</p>
			</li>
		</ul>
	</li>
	<li>
		<h4>Шарова система</h4>
		<p>Система повинна бути розбита на шари, кожен з яких відповідає за певні функції. Це дозволяє змінювати окремі частини системи без впливу на інші частини.</p>
	</li>
	<li>
		<h4>Код на вимогу (необов'язкове обмеження)</h4>
		<p>Сервер може надсилати клієнту код, який виконується на клієнті. Це дозволяє клієнту розширювати функціональність без необхідності змінювати сервер.</p>
	</li>
</ol>